\documentclass[10pt,t]{beamer}

\include{mypreamble}
\beamertemplateballitem

\newcolumntype{a}{>{\columncolor{lulime}}c}
\newcolumntype{b}{>{\columncolor{lulime!60}}c}


\hypersetup{
  pdftitle={C Programming}
  pdfauthor={Alexander B. Pacheco, LTS Research Computing, Lehigh University}
}

\title{C Programming I}


\author[Alex Pacheco]{\large{Alexander~B.~Pacheco}}
       
\institute{\href{http://researchcomputing.lehigh.edu}{LTS Research Computing}}

\date{\today}
     
\subject{Talks}
\keywords{Lehigh Research Computing Resources, C Programming}
% This is only inserted into the PDF information catalog. Can be left
% out. 


% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begingroup
  \setbeamertemplate{background canvas}[vertical shading][bottom=lubrown,top=lubrown]
  \setbeamertemplate{footline}[myfootline] 
  \setbeamertemplate{section page}[mysection]
  \frame[c]{
    \sectionpage
  }
  \endgroup
}

\titlegraphic{\includegraphics[scale=0.5]{lu}}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}{What is the C Language?}
  \begin{itemize}
    \item A general-purpose, procedural, imperative computer programming language.
    \item Developed in 1972 by Dennis M. Ritchie at the Bell Telephone Laboratories to develop the UNIX operating system.
    \item The UNIX operating system, the C compiler, and essentially all UNIX applications programs have been written in C.
    \item C is the most widely used computer language.
    \begin{itemize}
      \item Easy to learn
      \item Structured language
      \item Produces efficient programs
      \item Handles low-level activities
      \item Can be compiled on a variety of computer plaforms
    \end{itemize}
    \item Most of the state-of-the-art softwares have been implemented using C.
    \item Today's most popular Linux OS and RBDMS MySQL have been written in C.
  \end{itemize}
\end{frame}

\begin{frame}{What do you need to learn C?}
  \begin{enumerate}
    \item {C Compiler}
      \begin{itemize}
        \item What is a Compiler?
          \begin{itemize}
            \item A compiler is a computer program (or set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language, often having a binary form known as object code).
          \end{itemize}
        \item How does a compiler do?
          \begin{itemize}
            \item Translate C source code into a binary executable
          \end{itemize}
        \item List of Common Compilers:
          \begin{itemize}
            \item GCC GNU Project (Free, available on most *NIX systems)
            \item Intel Compiler
            \item Portland Group (PGI) Compiler
            \item Microsoft Visual Studio
            \item IBM XL Compiler
          \end{itemize}
      \end{itemize}
    \item {Text Editor}
      \begin{itemize}
        \item Emacs
        \item VI/VIM
        \item Notepad++ (avoid Notepad if you will eventually use a *NIX system)
        \item Integrated Development Environment: Eclipse, XCode, Visual Studio, etc
      \end{itemize}
  \end{enumerate}
\end{frame}

\section{Program Structure}
\begin{frame}[fragile]{Program Structure}
A C Program consists of the following parts
  \begin{itemize}
    \item Preprocessor Commands
    \item Functions
    \item Variables
    \item Statements \& Expressions
    \item Comments
  \end{itemize}
  \begin{columns}
    \column{0.5\textwidth}
    A Simple Hello World Code
    \lstinputlisting[language=C]{./Example/hello.c}
    \column{0.5\textwidth}
    Compile and execute the code
    \begin{lstlisting}[style=LINUX]
dyn100077:Exercise apacheco$ gcc hello.c 
dyn100077:Exercise apacheco$ ./a.out 
Hello World!
    \end{lstlisting}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{My First C Code}
  \lstinputlisting[language=C,numbers=left]{./Example/hello.c}
  \begin{itemize}
    \item \lstinline[language=C]|#include <stdio.h>| is a preprocessor command.
    \item[] It tells a C compiler to include stdio.h file before going to actual compilation.
    \item \lstinline[language=C]|int main()| is the main function where program execution begins.
    \item \lstinline[language=C]|/* ... */| is a comment and ignored by the compiler.
    \item \lstinline[language=C]|printf(...)| is function that prints \lstinline[language=C]|Hello World!| to the screen.
    \item \lstinline[language=C]|return 0;| terminates main() function and returns the value 0.
  \end{itemize}
\end{frame}

\section{Basic Syntax}
\begin{frame}[fragile,allowframebreaks]{Basic C Syntax}
  \begin{itemize}
    \item C is a case sensitive programming language i.e. program is not the same as Program or PROGRAM.
    \item Each individual statement must end with a semicolon. 
    \item Whitespace i.e. tabs or spaces is insignificant except whitespace within a character string.
    \item All C statments are free format i.e. no specified layout or column assignment as in FORTRAN77.
      \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
#include <stdio.h>
int main () {  /* My First C Code */  printf("Hello World!\n");  return 0;}
      \end{lstlisting}
    \item[] will produce the exact same result as the code on the previous slide.
    \item In C everything within \lstinline|/* and */| is a comment. Comments can span multiple lines.
      \begin{lstlisting}
/* this is single line comment */
/* This
is a 
multiline comment */
      \end{lstlisting}
%      \item Always use proper comments in your code. Your code will most likely be handed to someone long after you are gone.
%      \item Comments are completely ignored by compiler (test/debug code)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Valid Character Set in C language}
  \begin{center}
    \vspace{-0.5cm}
    \begin{tabular}{ab}
%      \hline
      {Alphabets} & ABCDEFGHIJKLMNOPQRSTUVWXYZ \\
      & abcdefghijklmnopqrstuvwxyz \\
      Digits                     & 0123456789 \\
%      \hline
    \end{tabular}
    \vspace{0.25cm}
    \newline
    \begin{tabular}{abababababababa}
%      \hline
      \rowcolor{lublue}\multicolumn{15}{a}{Special Characters} \\
%      \hline
      , & \_ & \{ & < & ' & ( & \Verb|^| & ; & \$ & / & *                & + & [ & \Verb|#| & ? \\ 
      . & \& & \} & > & " & ) & \Verb|!| & : & \% & | & \textbackslash{} & - & ] & \Verb|~| & \\
%      \hline
    \end{tabular}
    \vspace{0.25cm}
    \newline
    \begin{tabular}{cccc}
%      \hline
      \rowcolor{lublue}\multicolumn{4}{a}{Reserved Keywords}\\
%      \hline
      \rowcolor{lulime!60} auto     & double & int      & struct \\
      \rowcolor{lulime}    break    & else   & long     & switch \\
      \rowcolor{lulime!60} case     & enum   & register & typedef \\
      \rowcolor{lulime}    char     & extern & return   & union \\
      \rowcolor{lulime!60} continue & for    & signed   & void \\
      \rowcolor{lulime}    do       & if     & static   & while \\
      \rowcolor{lulime!60} default  & goto   & sizeof   & volatile \\
      \rowcolor{lulime}    const    & float  & short    & unsigned \\
%      \hline
    \end{tabular}
  \end{center}
  \begin{itemize}
    \item White space Characters: blank space, new line, horizontal tab, carriage return and form feed
  \end{itemize}
\end{frame}

\section{Data Types, Variables and Constants}
\begin{frame}{Data Types}
  \begin{description}
    \item[Basic Types:] There are five basic data types
      \begin{enumerate}
        \item int - integer: a whole number.
        \item float - floating point value: ie a number with a fractional part.
        \item double - a double-precision floating point value.
        \item char -  a single character.
        \item void - valueless special purpose type.
      \end{enumerate}
    \item[Derived Types:] These include
      \begin{enumerate}
        \item Pointers
        \item Arrays
        \item Structures
        \item Union
        \item Function
      \end{enumerate}
  \end{description}
  \begin{itemize}
    \item The array and structure types are referred to collectively as the aggregate types. 
    \item The type of a function specifies the type of the function's return value.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic Data Types: Integer}
  \begin{center}
    \begin{tabular}{ccc}
%      \hline
      \rowcolor{lublue}Type & Storage size (in bytes) & Value range \\
%      \hline
      \rowcolor{lulime}char            & 1      & -128 to 127 or 0 to 255 \\
      \rowcolor{lulime}unsigned char   & 1      & 0 to 255 \\
      \rowcolor{lulime}signed char     & 1      & -128 to 127 \\
%      \hline
      \rowcolor{lulime!60}\multirow{3}{*}{int} & 2 & -32,768 to 32,767 \\ \rowcolor{lulime!60}int & or & or \\ \rowcolor{lulime!60}& 4 &  -2,147,483,648 to 2,147,483,647 \\
%      \hline
      \rowcolor{lulime}\multirow{3}{*}{unsigned int} & 2 & 0 to 65,535 \\ \rowcolor{lulime}unsigned int& or & or  \\ \rowcolor{lulime}& 4 & 0 to 4,294,967,295 \\
%      \hline
      \rowcolor{lulime!60}short           & 2      & -32,768 to 32,767 \\
      \rowcolor{lulime!60}unsigned short  & 2      & 0 to 65,535 \\ 
%      \hline
      \rowcolor{lulime}long            & 4      & -2,147,483,648 to 2,147,483,647 \\
      \rowcolor{lulime}unsigned long   & 4      & 0 to 4,294,967,295 \\
%      \hline
    \end{tabular}
  \end{center}
  \begin{itemize}
    \item To get the exact size of a type or a variable on a particular platform, you can use the sizeof operator. 
    \item The expressions \lstinline|sizeof(type)| yields the storage size of the object or type in bytes. 
  \end{itemize}
\end{frame}

\begin{frame}{Basic Data Types: Floating-Point \& void}
  \begin{center}
    \begin{tabular}{abab}
%      \hline
      \rowcolor{lublue}Type & Storage size & Value range & Precision (decimal places) \\
%      \hline
      float       & 4 bytes  & 1.2E-38 to 3.4E38     & 6 \\
      double      & 8 bytes  & 2.3E-308 to 1.7E308   & 15 \\
      long double & 10 bytes & 3.4E-4932 to 1.1E4932 & 19 \\
%      \hline
    \end{tabular}
  \end{center}

  \begin{center}
    \begin{tabular}{ab}
%      \hline
      \rowcolor{lublue}Situation & Description \\
%      \hline
      function returns as void & function with no return value \\
      function arguments as void & function with no parameter \\
      pointers to void & address of an object without type \\
%      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Variables}
  \begin{itemize}
    \item Variables are memory location in computer's memory to store data.
    \item To indicate the memory location, each variable should be given a unique name called identifier. 
    \item Variable names are just the symbolic representation of a memory location.
    \item Rules for variable names:
    \begin{enumerate}
      \item Composed of letters (both uppercase and lowercase letters), digits and underscore '\_' only.
      \item The first letter of a variable should be either a letter or an underscore.
      \item There is no rule for the length of a variable name.
      \begin{itemize}
        \item Most likely your code will be used by someone else, so variable names should be meaningful and short as possible.
      \end{itemize}
    \end{enumerate}
    \begin{lstlisting}
int num;
float circle_area;
double _volume;
    \end{lstlisting}
    \item In C programming, you have to declare variable before using it in the program.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Declaring Variable or Variable Definition}
  \begin{itemize}
    \item A variable definition means to tell the compiler where and how much to create the storage for the variable. 
    \item A variable definition specifies a data type and contains a list of one or more variables of that type as follows:
    \item[] \lstinline{type variable_list;}
    \item \lstinline{type} must be a valid C data type or any user-defined object, etc., and 
    \item[] \lstinline{variable_list} may consist of one or more identifier names separated by commas.
    \item Variables can be initialized (assigned an initial value) in their declaration.
    \item[] \lstinline{type variable_name = value;}
  \end{itemize}
  \begin{lstlisting}
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
int d = 3, f = 5;           // definition and initializing d and f. 
byte z = 22;                // definition and initializes z. 
char x = 'x';               // the variable x has the value 'x'.
  \end{lstlisting}
\end{frame}

\begin{frame}{Constants \& Literals}
  The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals.
  {\footnotesize
    \begin{columns}
      \column{0.45\textwidth}
      \begin{block}{Integer Constants}
        \begin{tabular}{ll}
          85         & /* decimal */\\
          0213       & /* octal */\\
          0x4b       & /* hexadecimal */\\
          30         & /* int */\\
          30u        & /* unsigned int */\\
          30l        & /* long */\\
          30ul       & /* unsigned long */\\
        \end{tabular}
      \end{block}
      \begin{block}{Character Constants}
        \begin{tabular}{ll}
          'a'                               & /* character 'a' */\\
          'Z'                               & /* character 'Z' */\\
          \textbackslash?                   & /*? character */\\
          \textbackslash{}\textbackslash{}  & /*\textbackslash{} character */\\
          \textbackslash{}n                 & /*Newline */\\
          \textbackslash{}r                 & /*Carriage return */\\
          \textbackslash{}t                 & /*Horizontal tab */\\
        \end{tabular}
      \end{block}
      \column{0.45\textwidth}
      \begin{block}{Floating Point Constants}
        \begin{tabular}{ll}
          3.1416    & \\
          314159E-5 & /* 3.14159 */\\
          2.1E+5    & /* 2.1x$10^5$*/\\
          3.7E-2    & /* 0.037 */\\
          0.5E7     & /* 5.0x$10^6$*/\\
          -2.8E-2   & /* -0.028 */\\
        \end{tabular}
      \end{block}
        \begin{block}{String Constants}
          \begin{tabular}{ll}
            "hello, world"  & /* normal string */\\
            "c programming \textbackslash{} & \multirow{2}{*}{/* multi-line string */}\\
            language" & \\
          \end{tabular}
      \end{block}
    \end{columns}
  }
\end{frame}

\begin{frame}[fragile]{How to define Constants}
  \begin{itemize}
    \item Constants can be defined in two ways
    \begin{enumerate}
      \item Using the \lstinline{#define} preprocessor (defining a macro)
      \item Using the \lstinline{const} keyword (new standard borrowed from C++)
    \end{enumerate}
  \end{itemize}
  \lstinputlisting[language=C]{./Example/const.c}
\end{frame}

\begin{frame}{Input and Output}
  \begin{itemize}
    \item C or any programming language in general needs to be interactive i.e. write something back and optionally read data to be useful.
    \item Similar to Unix, C treats all devices as files.
      \begin{center}
        \begin{tabular}{abb}
%          \hline
          \rowcolor{lublue}Standard File & File Pointer & Device \\
%          \hline
          Standard Input & stdin & Keyboard \\
          Standard Output & stdout & Screen \\
          Standard Error & stderr & Screen\\
%          \hline
        \end{tabular}
      \end{center}
      
    \item C Programming language provides three functions to read/write from standard input/output
      \begin{center}
        \begin{tabular}{cccc}
%          \hline
          \rowcolor{lublue}& \multicolumn{2}{c}{Unformatted} & Formatted \\
%          \hline
          \rowcolor{lulime}Input & getchar & gets & scanf \\
          \rowcolor{lulime!60}Output & putchar & puts & printf \\
%          \hline
        \end{tabular}
      \end{center}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Unformatted I/O}
  \begin{block}{The getchar() \& putchar() functions}
    \begin{itemize}
      \item The \lstinline|int getchar(void)| function reads the next available character from the screen and returns it as an integer. 
      \item[] This function reads only single character at a time.
      \item The \lstinline|int putchar(int c)| function puts the passed character on the screen and returns the same character. 
      \item[] This function puts only single character at a time. 
    \end{itemize}
  \end{block}

  \begin{block}{The gets() \& puts() functions}
    \begin{itemize}
      \item The \lstinline|char *gets(char *s)| function reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF.
      \item The \lstinline|int puts(const char *s)| function writes the string s and a trailing newline to stdout.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \begin{columns}
    \column{0.5\textwidth}
    \lstinputlisting[language=C]{./Example/readiounfmt1.c}
    \column{0.5\textwidth}
    \lstinputlisting[language=C]{./Example/readiounfmt2.c}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Formatted I/O}
  \begin{itemize}
    \item The \lstinline|int scanf(const char *format, ...)| function reads input from the standard input stream stdin and scans that input according to format provided.
    \item The \lstinline|int printf(const char *format, ...)| function writes output to the standard output stream stdout and produces output according to a format provided (optional).
      \lstinputlisting[language=C]{./Example/helloworld.c}
    \item In this program, the user is asked a input and value is stored in variable \lstinline|name|.
    \item Note the '\lstinline|&|' sign before \lstinline|name|.
    \item \lstinline|&name| denotes the address of \lstinline|name| and value is stored in that address.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Common Format Specifier}
  \begin{itemize}
    \item The format specifier: \lstinline|%[flags][width][.precision][length]specifier| 
  \end{itemize}
  \begin{center}
    \begin{tabular}{cl}
%      \hline
      \rowcolor{lublue}flag & meaning \\
%      \hline
      \rowcolor{lulime}- & left justify \\
      \rowcolor{lulime}+ & always display sign\\
      \rowcolor{lulime}0 & pad with leading zeros\\
%      \hline
    \end{tabular}
  \end{center}
  \begin{center}
    \begin{tabular}{ccc}
%      \hline
      \rowcolor{lublue}Specifier & Output & Example\\
%      \hline
      \rowcolor{lulime}\%f & decimal float & 3.456 \\
%      \hline
      \rowcolor{lulime!80}\%7.5f & decimal float, 7 digit width and 5 digit precision & 3.45600 \\
%      \hline
      \rowcolor{lulime}\%d & integer & 5\\
%      \hline
      \rowcolor{lulime!70}\%05d & integer, 5 digits pad with zeros & 00101 \\
%      \hline
      \rowcolor{lulime}\%s & string of characters & "Hello World!"\\
%      \hline
      \rowcolor{lulime!60}\%e & scientific notation for decimal float & 2.71828e+5  \\
%      \hline
      \rowcolor{lulime}\%c & character &  \\
%      \hline
      \rowcolor{lulime!50}\textbackslash{}n & insert new line & \\
%      \hline
      \rowcolor{lulime}\textbackslash{}t & insert tab & \\
%      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]{}
  \lstinputlisting[language=C]{./Example/print.c}
  \begin{lstlisting}[style=LINUX]
alexanders-mbp:Example apacheco$ gcc -o print print.c
alexanders-mbp:Example apacheco$ ./print
Characters: a A 
Decimals: 2014 0065
         floats: 3.14160        3.141600        3.141600e+00 
hello world 

  \end{lstlisting}
\end{frame}

\section{Programming Operators}
\begin{frame}{Operators}
  \begin{itemize}
    \item Arithmetic
      \begin{center}
        \begin{tabular}{ab}
%          \hline
          \rowcolor{lublue}Operator & Meaning \\
%          \hline
          +  & addition or unary plus \\
          -  & subtraction or  unary minus \\
          *  & multiplication \\
          /  & division \\
          \% & remainder after division( modulo division) \\
          ++ & increase integer value by one \\
          -- & decrease integer value by one \\
%          \hline
        \end{tabular}
      \end{center}
      \item Assignment Operator
        \begin{center}
          \begin{tabular}{abb}
%            \hline
            \rowcolor{lublue}Operator & Example & Same as \\
%            \hline
            =   & a=b   & a=b \\
            +=  & a+=b  & a=a+b \\
            -=  & a-=b  & a=a-b \\
            *=  & a*=b  & a=a*b \\
            /=  & a/=b  & a=a/b \\
            \%= & a\%=b & a=a\%b \\
%            \hline
          \end{tabular}
        \end{center}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Increment/Decrement Operator}
  \begin{itemize}
    \item There are two types of increment/decrement operators
    \begin{enumerate}
      \item Suffix or Postfix: e.g. i++ or j{-}{-}
      \item[] a=i++ means set a to i and then increment i by 1
      \item Prefix: ++i or {-}{-}j
      \item[] a=++i means increment i by 1 and then set a to i
    \end{enumerate}
    \item Consider the following example
    \item[] If i = 1 and j = 2, then
    \item[] ++i + j++ = 4
    \item[] and not 5 since j is incremented after the operation is complete
  \end{itemize}
  \begin{columns}
    \column{0.45\textwidth}
    \lstinputlisting[basicstyle=\tiny\ttfamily]{./Example/increment.c}
    \column{0.45\textwidth}
    \begin{lstlisting}[style=LINUX]
alexanders-mbp:Example apacheco$ make increment
cc     increment.c   -o increment
alexanders-mbp:Example apacheco$ ./increment
++i + j++: 4
a=++i: 2, b=j++: 2, i:2, j:3
a(=++i) + b(=j++): 4
    \end{lstlisting}
  \end{columns}
\end{frame}

\begin{frame}{Relational Operators}
  \begin{itemize}
  \item Relational operators checks relationship between two operands.
  \item If the relation is true, it returns value 1 and if the relation is false, it returns value 0.
  \item Relational operators are used in decision making and loops in C programming.
  \end{itemize}
  \begin{center}
    \begin{tabular}{abb}
%      \hline
      \rowcolor{lublue}Operator & Meaning & Example \\
%      \hline
      == & Equal to                 & 5==3 returns false (0) \\
      >  & Greater than             & 5>3 returns true (1) \\
      <  & Less than                & 5<3 returns false (0) \\
      != & Not equal to             & 5!=3 returns true(1) \\
      >= & Greater than or equal to & 5>=3 returns true (1) \\
      <= & Less than or equal to    & 5<=3 return false (0) \\
%      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Logical \& Conditional Operators}
  \begin{itemize}
  \item Logical operators are used to combine expressions containing relation operators.
  \item In C, there are 3 logical operators
  \end{itemize}
  \begin{center}
    \begin{tabular}{abb}
%      \hline
      \rowcolor{lublue}Operator & Meaning & Example \\
%      \hline
      \&\& & Logial AND  & If c=5 and d=2 then,((c==5) \&\& (d>5)) returns false. \\
      ||   & Logical OR  & If c=5 and d=2 then, ((c==5) || (d>5)) returns true. \\
      !    & Logical NOT & If c=5 then, !(c==5) returns false. \\
%      \hline
    \end{tabular}
  \end{center}
  \begin{itemize}
  \item Conditional Operator: Conditional operators are used in decision making in C programming, i.e, executes different statements according to test condition whether it is either true or false.
  \item[] \lstinline|conditional_expression?expression1:expression2|
  \item If the test condition is true, expression1 is returned and if false expression2 is returned.
  \item[] \lstinline|d=(c>0)?10:-10;|
  \item[] If c is greater than 0, value of d will be 10 but, if c is less than 0, value of d will be -10.
  \end{itemize}
\end{frame}

\begin{frame}{Other Operators}
\end{frame}

\begin{frame}[fragile]{Operator Precedance}
  \scriptsize{
    \begin{center}
      \begin{tabular}{ccc}
        \hline
        \rowcolor{lublue}Operator & Description & Associativity \\
        \rowcolor{lulime!60}++, {-}{-} & Suffix Increment/Decrement & $\rightarrow$ \\
        \rowcolor{lulime}++, {-}{-} & Prefix Increment/Decrement & $\leftarrow$ \\
        \rowcolor{lulime!60}+, - & Unary plus and minus &  \\
        \rowcolor{lulime}!, \Verb|~| & Logical NOT and Bitwise NOT & \\
        \rowcolor{lulime!60}* & Indirection (dereference) & \\
        \rowcolor{lulime}\& & Address of & \\
        \rowcolor{lulime!60}sizeof & Size-of & \\
        \rowcolor{lulime}{*, /, \%} & Multiplication, division, modulo & $\rightarrow$ \\
        \rowcolor{lulime!60}{+, -} & Addition, Subtraction & \\
        \rowcolor{lulime}{<<, >>} & Bitwise left and right shift & \\
        \rowcolor{lulime!60}{<, <=} & Relational Operators & \\ 
        \rowcolor{lulime}{>, >= } &  & \\ 
        \rowcolor{lulime!60}{==, !=} &  & \\ 
        \rowcolor{lulime}{\&} & Bitwise AND & \\
        \rowcolor{lulime!60}{\Verb|^|} & Bitwise XOR & \\
        \rowcolor{lulime}{|} & Bitwise OR & \\
        \rowcolor{lulime!60}{\&\&} & Logical AND & \\
        \rowcolor{lulime}{||} & Logical OR & \\
        \rowcolor{lulime!60}{?:} & Ternary Conditional & $\leftarrow$ \\
        \rowcolor{lulime}{=} & Simple Assignment &  \\
        \rowcolor{lulime!60}{+=, -=} & Assignment by sum and difference & \\
        \rowcolor{lulime}{*=, /=, \%=} & Assignment by product, quotient and remainder & \\
        \rowcolor{lulime!60}{<<=, >>=} & Assignment by bitwise left and right shift & \\
        \rowcolor{lulime}{\&=, \Verb|^=|, |=} & Assignment by logical AND, XOR and OR & \\
        \rowcolor{lulime!60}{,} & Comma Operator & $\rightarrow$ \\
        \hline
      \end{tabular}
    \end{center}
  }
\end{frame}

\section{Control Flow}
\begin{frame}{Control Flow}
  \begin{itemize}
    \item Conditional Statements (decision making/selection)
    \begin{itemize}
      \item if $\cdots$ else if $\cdots$ else
      \item switch
    \end{itemize}
    \item Loops
    \begin{itemize}
      \item for
      \item while
      \item do while
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{if statement}
  \begin{itemize}
    \item An if statement consists of a boolean expression followed by one or more statements.
      \begin{block}{}
        \begin{lstlisting}
if(boolean_expression)
{
   /* statement(s) will execute if the boolean expression is true */
}
        \end{lstlisting}
      \end{block}
    \item If the boolean expression evaluates to true, then the block of code inside the if statement will be executed. 
    \item If boolean expression evaluates to false, then the first set of code after the end of the if statement(after the closing curly brace) will be executed.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{if $\cdots$ else statement}
  \begin{itemize}
    \item An if statement can be followed by an optional else statement, which executes when the boolean expression is false.
      \begin{block}{}
        \begin{lstlisting}
if(boolean_expression)
{
   /* statement(s) will execute if the boolean expression is true */
}
else
{
  /* statement(s) will execute if the boolean expression is false */
}
        \end{lstlisting}
      \end{block}
    \item If the boolean expression evaluates to true, then the if block of code will be executed, otherwise else block of code will be executed.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{if $\cdots$ else if $\cdots$ else statement}
  \begin{itemize}
    \item An if statement can be followed by an optional else if$\cdots$else statement,
    \item very useful to test various conditions using single if$\cdots$else if statement.
    \item When using if , else if , else statements there are few points to keep in mind:
    \begin{itemize}
      \item An if can have zero or one else's and it must come after any else if's.
      \item An if can have zero to many else if's and they must come before the else.
      \item Once an else if succeeds, none of the remaining else if's or else's will be tested.
    \end{itemize}
      \begin{block}{}
        \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
if(boolean_expression 1)
{
   /* Executes when the boolean expression 1 is true */
}
else if( boolean_expression 2)
{
   /* Executes when the boolean expression 2 is true */
}
else if( boolean_expression 3)
{
   /* Executes when the boolean expression 3 is true */
}
else 
{
   /* executes when the none of the above condition is true */
}
        \end{lstlisting}
      \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{}
  \lstinputlisting[language=C]{./Example/ifelseif.c}
\end{frame}

\begin{frame}[fragile]{Nested if$\cdots$else statement}
  \begin{itemize}
    \item You can use one if or else if statement inside another if or else if statement(s) i.e. nested if$\cdots$else statement/s
      \begin{block}{}
        \begin{lstlisting}
if( boolean_expression 1)
{
   /* Executes when the boolean expression 1 is true */
   if(boolean_expression 2)
   {
      /* Executes when the boolean expression 2 is true */
   }
}
        \end{lstlisting}
      \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{}
  \lstinputlisting[language=C]{./Example/nestedif.c}
\end{frame}

\begin{frame}[fragile]{switch statement}
  \begin{itemize}
    \item A switch statement allows a variable to be tested for equality against a list of values. 
    \item Each value is called a case, and the variable being switched on is checked for each switch case.
      \begin{block}{}
        \begin{lstlisting}
switch(expression){
    case constant-expression  :
       statement(s);
       break; /* optional */
    case constant-expression  :
       statement(s);
       break; /* optional */
  
    /* you can have any number of case statements */
    default : /* Optional */
       statement(s);
}
        \end{lstlisting}
      \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \begin{itemize}
    \item The expression used in a switch statement must have an integral type 
    \item[](or enumerated type, or be of a class type in which the class has a single conversion function to an integral or enumerated type).
    \item You can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon.
    \item The constant-expression for a case must be the same data type as the variable in the switch, and it must be a constant or a literal.
    \item When the variable being switched on is equal to a case, the statements following that case will execute until a break statement is reached.
    \item When a break statement is reached, the switch terminates, and the flow of control jumps to the next line following the switch statement.
    \item Not every case needs to contain a break. If no break appears, the flow of control will fall through to subsequent cases until a break is reached.
    \item A switch statement can have an optional default case, which must appear at the end of the switch. 
    \item The default case can be used for performing a task when none of the cases is true. No break is needed in the default case.
  \end{itemize}
  \lstinputlisting[language=C,basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{./Example/switch.c}
\end{frame}

\begin{frame}[fragile]{Nested Conditional Statements}
  \begin{itemize}
    \item Conditional statements can be nested as they do not overlap:
  \end{itemize}
  \begin{lstlisting}
if( boolean_expression 1) {
  if(boolean_expression 2) {
    /* Executes when the boolean expression 2 is true */
    /* nested switch statement */
    switch(expression){
    case constant-expression :
      statement(s);
      break; /* optional */
    case constant-expression :
      statement(s);
      break; /* optional */
      /* you can have any number of case statements */
    default : /* Optional */
      statement(s);
    }
  }
 }
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{for loop}
  \begin{itemize}
    \item A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.
      \begin{itemize}
        \item The init step is executed first and only once.
        \item the condition is evaluated. If it is true, the body of the loop is executed. If it is false, the body of the loop does not execute, the loop exits.
        \item the increment statement executes after the loop body.
        \item The loop continues until the condition becomes false
      \end{itemize}
  \end{itemize}
  \begin{block}{}
    \begin{lstlisting}
for ( init; condition; increment )
{
   statement(s);
}
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]{while and do$\cdots$while loops}
  \begin{itemize}
    \item while loops are similar to for loops
    \item A while loop continues executing the code block as long as the condition in the while holds.
      \begin{block}{}
        \begin{lstlisting}
while(condition)
{
   statement(s);
}
        \end{lstlisting}
      \end{block}
    \item do$\cdots$while loop is guaranteed to execute at least one time.
      \begin{block}{}
        \begin{lstlisting}
do
{
   statement(s);

}while( condition );
        \end{lstlisting}
      \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Simple loops using for, while, do while}
  \lstinputlisting[language=C]{./Example/loops.c}
\end{frame}

\begin{frame}[fragile]{Nested loops in C}
  \begin{itemize}
    \item All loops can be nested as long as they do not overlap
  \end{itemize}
  \begin{columns}
    \column{0.45\textwidth}
    \begin{block}{}
      \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
/* nested for loops*/
for (init; condition; increment) {
  for (init; condition; increment) {
    statement(s);
  }
  statement(s);
 }
/* nested while loops*/
while (condition) {
  while (condition) {
    statement(s);
  }
  statement(s);
 }
      \end{lstlisting}
    \end{block}
    \column{0.45\textwidth}
    \begin{block}{}
      \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
/* nested do while loops*/
do {
  statement(s);
  do {
    statement(s);
  } while ( condition );
 } while ( condition );
/* mixed type loops*/
while (condition) {
  for (init; condition; increment) {
    statement(s);
    do {
      statement(s);
    } while ( condition );
  }
  statement(s);
 }
      \end{lstlisting}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \begin{block}{}
    \lstinputlisting[basicstyle=\scriptsize\ttfamily]{./Example/nestedfor.c}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Loop Control Statement}
  \begin{itemize}
    \item Loop control statements change execution from its normal sequence.
      \begin{description}
        \item[break:] Terminates the loop or switch statement
        \item[continue:] Causes the loop to skip the remainder of its body for the current iteration
        \item[goto:] Transfers control to the labeled statement. Use is not advised
      \end{description}
  \end{itemize}
  \begin{columns}
    \column{0.45\textwidth}
    \lstinputlisting[basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{./Example/break.c}
    \column{0.45\textwidth}
    \lstinputlisting[basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{./Example/continue.c}
  \end{columns}
\end{frame}

\begin{frame}{Exercise}
  \begin{enumerate}
    \item Print list of prime numbers less than 100
    \item Calculate circumference and area of a circle for given radius
    \item Obtain roots of a quadratic equations
    \item Calculate factorial of a number
  \end{enumerate}
\end{frame}

\end{document}

